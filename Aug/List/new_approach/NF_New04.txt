Step 1: Setup  Three Angular 18/20 projects:

root/
 ‚îú‚îÄ shell/           <-- shell app
 ‚îú‚îÄ mfe1/            <-- product microfrontend
 ‚îî‚îÄ mfe2/            <-- orders microfrontend
 
Use:
ng new shell --routing --standalone --style=scss
ng new mfe1  --routing --standalone --style=scss
ng new mfe2  --routing --standalone --style=scss
=====================================================================================================================
Step 2: Configure native federation  Each app uses the angular.json (or project.json) to declare federation ‚Äî NO webpack config.

"federation": {
  "remotes": {
    "mfe1": "http://localhost:4201/remoteEntry.json",
    "mfe2": "http://localhost:4202/remoteEntry.json"
  }
}

MFE1: angular.json
"federation": {
  "name": "mfe1",
  "exposes": {
    "./ProductModule": "./src/app/product/product.module.ts"
  }
}

 MFE2: angular.json
"federation": {
  "name": "mfe2",
  "exposes": {
    "./OrdersModule": "./src/app/orders/orders.module.ts"
  }
}
=====================================================================================================================
Step 3: Implement modules to expose
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { ProductComponent } from './product.component';

@NgModule({
  declarations: [ProductComponent],
  imports: [
    RouterModule.forChild([
      { path: '', component: ProductComponent }
    ])
  ]
})
export class ProductModule {}
The name ProductModule must match the key: "./ProductModule".

MFE2: orders/orders.module.ts

import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { OrdersComponent } from './orders.component';

@NgModule({
  declarations: [OrdersComponent],
  imports: [
    RouterModule.forChild([
      { path: '', component: OrdersComponent }
    ])
  ]
})
export class OrdersModule {}
=====================================================================================================================
Step 4: Shell lazy loads remote modules
npm install @angular-architects/native-federation

shell/src/app/app.routes.ts
import { Routes } from '@angular/router';
import { loadRemoteModule } from '@angular-architects/native-federation';

export const routes: Routes = [
  { path: '', redirectTo: 'home', pathMatch: 'full' },
  { path: 'home', loadComponent: () => import('./home/home.component').then(m => m.HomeComponent) },
  {
    path: 'products',
    loadChildren: () =>
      loadRemoteModule({
        type: 'manifest',
        remoteName: 'mfe1',
        exposedModule: './ProductModule'
      }).then(m => m.ProductModule)
  },
  {
    path: 'orders',
    loadChildren: () =>
      loadRemoteModule({
        type: 'manifest',
        remoteName: 'mfe2',
        exposedModule: './OrdersModule'
      }).then(m => m.OrdersModule)
  }
];

Shell AppComponent:
import { Component } from '@angular/core';
import { RouterOutlet, RouterLink } from '@angular/router';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet, RouterLink],
  template: `
    <h1>Shell App</h1>
    <nav>
      <a routerLink="/home">Home</a> |
      <a routerLink="/products">Products (MFE1)</a> |
      <a routerLink="/orders">Orders (MFE2)</a>
    </nav>
    <router-outlet></router-outlet>
  `
})
export class AppComponent {}




=====================================================================================================================
Step 5: Run all apps
MFE1 ‚Üí serve on http://localhost:4201

MFE2 ‚Üí serve on http://localhost:4202

Shell ‚Üí serve on http://localhost:4200
=====================================================================================================================
Final file structure (simplified):
root/
 ‚îú‚îÄ shell/
 ‚îÇ   ‚îú‚îÄ src/app/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ app.component.ts
 ‚îÇ   ‚îÇ   ‚îî‚îÄ app.routes.ts
 ‚îú‚îÄ mfe1/
 ‚îÇ   ‚îî‚îÄ src/app/product/
 ‚îÇ       ‚îú‚îÄ product.component.ts
 ‚îÇ       ‚îî‚îÄ product.module.ts
 ‚îî‚îÄ mfe2/
     ‚îî‚îÄ src/app/orders/
         ‚îú‚îÄ orders.component.ts
         ‚îî‚îÄ orders.module.ts


=====================================================================================================================
Enterprise solutions
https://products.mycompany.com/remoteEntry.json  
https://orders.mycompany.com/remoteEntry.json  
https://profile.mycompany.com/remoteEntry.json  
https://reports.mycompany.com/remoteEntry.json  
https://admin.mycompany.com/remoteEntry.json  


=====================================================================================================================
Step 1: Each MFE repo ‚Üí build with native federation
In each MFE project‚Äôs angular.json ‚Üí add under "build": "options":

Example for products:

"federation": {
  "name": "products",
  "exposes": {
    "./ProductsModule": "./src/app/products/products.module.ts"
  }
}

Then build & deploy to:  https://products.mycompany.com/remoteEntry.json

=====================================================================================================================

Step 2: Shell repo ‚Üí configure remotes
Shell app has its own separate repo.
In shell‚Äôs angular.json ‚Üí under "build" ‚Üí "options":

=====================================================================================================================
"federation": {
  "remotes": {
    "products": "https://products.mycompany.com/remoteEntry.json",
    "orders":   "https://orders.mycompany.com/remoteEntry.json",
    "profile":  "https://profile.mycompany.com/remoteEntry.json",
    "reports":  "https://reports.mycompany.com/remoteEntry.json",
    "admin":    "https://admin.mycompany.com/remoteEntry.json"
  }
}


===================================================================================================================
Step 3: Shell loads remotes dynamically (at runtime)  In shell/src/app/app.routes.ts:

import { Routes } from '@angular/router';
import { loadRemoteModule } from '@angular-architects/native-federation';

export const routes: Routes = [
  { path: '', redirectTo: 'home', pathMatch: 'full' },

  {
    path: 'products',
    loadChildren: () =>
      loadRemoteModule({
        type: 'manifest',
        remoteName: 'products',
        exposedModule: './ProductsModule'
      }).then(m => m.ProductsModule)
  },
  {
    path: 'orders',
    loadChildren: () =>
      loadRemoteModule({
        type: 'manifest',
        remoteName: 'orders',
        exposedModule: './OrdersModule'
      }).then(m => m.OrdersModule)
  },
  {
    path: 'profile',
    loadChildren: () =>
      loadRemoteModule({
        type: 'manifest',
        remoteName: 'profile',
        exposedModule: './ProfileModule'
      }).then(m => m.ProfileModule)
  },
  {
    path: 'reports',
    loadChildren: () =>
      loadRemoteModule({
        type: 'manifest',
        remoteName: 'reports',
        exposedModule: './ReportsModule'
      }).then(m => m.ReportsModule)
  },
  {
    path: 'admin',
    loadChildren: () =>
      loadRemoteModule({
        type: 'manifest',
        remoteName: 'admin',
        exposedModule: './AdminModule'
      }).then(m => m.AdminModule)
  }
];


remoteName string must exactly match the name in each remote‚Äôs federation config.
‚ö† exposedModule string must match the key in the MFE expose config.
=====================================================================================================================
Step 4: Each MFE exposes a module  For example, in products MFE repo:

"federation": {
  "name": "products",
  "exposes": {
    "./ProductsModule": "./src/app/products/products.module.ts"
  }
}



And products.module.ts:

import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { ProductsComponent } from './products.component';

@NgModule({
  declarations: [ProductsComponent],
  imports: [
    RouterModule.forChild([
      { path: '', component: ProductsComponent }
    ])
  ]
})
export class ProductsModule {}

=====================================================================================================================
Same for other MFEs:

orders ‚Üí OrdersModule

profile ‚Üí ProfileModule

reports ‚Üí ReportsModule

admin ‚Üí AdminModule

=====================================================================================================================
Step 5: Each remote builds & deploys separately
When you run:
ng build

in the products repo, it produces:
dist/
 ‚îî‚îÄ remoteEntry.json
 
 You deploy this + static assets to your domain:
https://products.mycompany.com/remoteEntry.json



=====================================================================================================================
Step 6: Shell at runtime dynamically loads them

When user navigates to /products, Angular uses:

loadRemoteModule + remoteEntry.json at the specified URL

Loads ProductsModule on demand

All MFEs are completely independent ‚Üí separate teams, separate CI/CD, separate repos.

Shell only has to know the URLs of the remotes.

You can update each MFE independently ‚Üí deploy new version without redeploying shell (unless API changes).
=====================================================================================================================

 File structure overview:

shell/
 ‚îú‚îÄ src/
 ‚îÇ   ‚îú‚îÄ app/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ app.routes.ts
 ‚îÇ   ‚îÇ   ‚îî‚îÄ app.component.ts
 ‚îÇ   ‚îî‚îÄ main.ts
 ‚îî‚îÄ angular.json

mfe1/ (products)
 ‚îú‚îÄ src/app/products/
 ‚îÇ   ‚îú‚îÄ products.component.ts
 ‚îÇ   ‚îî‚îÄ products.module.ts
 ‚îî‚îÄ angular.json

mfe2/ (orders)
 ‚îú‚îÄ src/app/orders/
 ‚îÇ   ‚îî‚îÄ orders.module.ts
 ‚îî‚îÄ angular.json

... same for profile, reports, admin

=====================================================================================================================
Fully standalone components & modules

üõ† Native federation only (angular.json federation key, no webpack config)

‚ö° ESBuild

üß© Shell + 5 MFEs each in separate repos, built & deployed independently

üß¨ Use Angular‚Äôs new signal store for state management

üóÉ Simple UI-level data persistence (e.g., localStorage)



Shell
Angular 20, uses standalone bootstrap

Federation remotes configured in angular.json

App-level store using Signal Store

Routes lazy-load MFEs using loadRemoteModule

Navbar linking to MFEs



Products, Orders, Profile, Reports, Admin

Each:

Angular 20

Standalone Module (for now, could later go fully standalone components)

Exposed in angular.json federation

Simple component(s)

Each uses Signal Store to manage local state

UI-level persistence: save state in localStorage


Native federation & esbuild only
No webpack.config.js

Only angular.json ‚Üí federation key

Use @ngrx/signals or Angular's new signal store (depends on exact version)

Example: products MFE keeps its product list in signal store; persists in localStorage

Shell may keep global user profile or feature toggles in its own store


root/
 ‚îú‚îÄ shell/                   # Shell repo
 ‚îÇ   ‚îú‚îÄ src/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ app/
 ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ app.component.ts
 ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ app.routes.ts
 ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ stores/         <-- signal store
 ‚îÇ   ‚îÇ   ‚îî‚îÄ main.ts
 ‚îÇ   ‚îî‚îÄ angular.json
 ‚îú‚îÄ mfe-products/            # MFE1 repo
 ‚îÇ   ‚îú‚îÄ src/app/products/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ products.module.ts
 ‚îÇ   ‚îÇ   ‚îú‚îÄ products.component.ts
 ‚îÇ   ‚îÇ   ‚îî‚îÄ stores/
 ‚îÇ   ‚îî‚îÄ angular.json
 ‚îú‚îÄ mfe-orders/              # MFE2 repo
 ‚îú‚îÄ mfe-profile/             # MFE3 repo
 ‚îú‚îÄ mfe-reports/             # MFE4 repo
 ‚îî‚îÄ mfe-admin/               # MFE5 repo



 Shell angular.json ‚Üí federation
"federation": {
  "remotes": {
    "products": "https://products.mycompany.com/remoteEntry.json",
    "orders":   "https://orders.mycompany.com/remoteEntry.json",
    "profile":  "https://profile.mycompany.com/remoteEntry.json",
    "reports":  "https://reports.mycompany.com/remoteEntry.json",
    "admin":    "https://admin.mycompany.com/remoteEntry.json"
  }
}

mfe-products angular.json ‚Üí federation
"federation": {
  "name": "products",
  "exposes": {
    "./ProductsModule": "./src/app/products/products.module.ts"
  }
}



Shell: store using signal store (simplified)
src/app/stores/user.store.ts:
import { Injectable, computed, signal } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class UserStore {
  private _user = signal<{ name: string; email: string } | null>(null);

  readonly user = computed(() => this._user());

  setUser(user: { name: string; email: string }) {
    this._user.set(user);
    localStorage.setItem('user', JSON.stringify(user));
  }

  loadFromLocalStorage() {
    const data = localStorage.getItem('user');
    if (data) this._user.set(JSON.parse(data));
  }

  clear() {
    this._user.set(null);
    localStorage.removeItem('user');
  }
}
Call userStore.loadFromLocalStorage() in AppComponent constructor.

MFE products: store  src/app/products/stores/products.store.ts:

import { Injectable, signal, computed } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class ProductsStore {
  private _products = signal<string[]>([]);

  readonly products = computed(() => this._products());

  addProduct(name: string) {
    const updated = [...this._products(), name];
    this._products.set(updated);
    localStorage.setItem('products', JSON.stringify(updated));
  }

  loadFromLocalStorage() {
    const data = localStorage.getItem('products');
    if (data) this._products.set(JSON.parse(data));
  }

  clear() {
    this._products.set([]);
    localStorage.removeItem('products');
  }
}


ProductsModule: standalone module
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { ProductsComponent } from './products.component';

@NgModule({
  declarations: [ProductsComponent],
  imports: [
    RouterModule.forChild([{ path: '', component: ProductsComponent }])
  ]
})
export class ProductsModule {}


ProductsComponent
import { Component, OnInit } from '@angular/core';
import { ProductsStore } from './stores/products.store';

@Component({
  selector: 'app-products',
  standalone: true,
  template: `
    <h2>Products</h2>
    <input [(ngModel)]="newProduct" placeholder="New product">
    <button (click)="add()">Add</button>
    <ul>
      <li *ngFor="let p of store.products()">{{ p }}</li>
    </ul>
  `
})
export class ProductsComponent implements OnInit {
  newProduct = '';

  constructor(public store: ProductsStore) {}

  ngOnInit() {
    this.store.loadFromLocalStorage();
  }

  add() {
    if (this.newProduct.trim()) {
      this.store.addProduct(this.newProduct.trim());
      this.newProduct = '';
    }
  }
}

üß© Shell: app.routes.ts

import { Routes } from '@angular/router';
import { loadRemoteModule } from '@angular-architects/native-federation';

export const routes: Routes = [
  { path: '', redirectTo: 'home', pathMatch: 'full' },
  {
    path: 'products',
    loadChildren: () =>
      loadRemoteModule({
        type: 'manifest',
        remoteName: 'products',
        exposedModule: './ProductsModule'
      }).then(m => m.ProductsModule)
  },
  // ... orders, profile, reports, admin similar
];



Then:
Build & deploy each MFE ‚Üí its own URL

Shell points to those URLs in angular.json federation

On runtime, user navigates ‚Üí shell loads remote module via remoteEntry.json

üì¶ Store pattern:
Each MFE keeps its own state in signal store

State persisted to localStorage

Keeps MFEs fully independent

üöÄ Next step (what I‚Äôll do for you):
‚úÖ Build real code for shell + 5 MFEs
‚úÖ Use Angular 20 standalone APIs, esbuild, native federation
‚úÖ Add real signal stores
‚úÖ Show full file structure
‚úÖ Deep dive slides (architecture, flow, config)
‚úÖ ZIP or GitHub repo for download


Here‚Äôs Part‚ÄØ1: the real code ‚Äî fully written out as file listings (with real content)
And then Part‚ÄØ2: business-friendly presentation slides (high-level + technical overview)

Everything is:
‚úÖ Angular‚ÄØ20
‚úÖ Standalone components/modules
‚úÖ ESBuild
‚úÖ Native Federation via angular.json only (no webpack config)
‚úÖ Shell + 5 MFEs (products, orders, profile, reports, admin) ‚Äî each in its own repo
‚úÖ Signal store with basic persistence to localStorage

Part‚ÄØ1: Real code (full listing)
üß© Each MFE is a separate Angular repo.
üè† Shell is a separate Angular repo too.

I‚Äôll keep code concise but complete so you can copy-paste.

 shell/
shell/
 ‚îú‚îÄ src/app/
 ‚îÇ   ‚îú‚îÄ app.component.ts
 ‚îÇ   ‚îú‚îÄ app.routes.ts
 ‚îÇ   ‚îî‚îÄ stores/
 ‚îÇ       ‚îî‚îÄ user.store.ts
 ‚îú‚îÄ src/main.ts
 ‚îî‚îÄ angular.json

shell/src/main.ts

import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { provideRouter } from '@angular/router';
import { routes } from './app/app.routes';

bootstrapApplication(AppComponent, {
  providers: [provideRouter(routes)]
}).catch(err => console.error(err));

shell/src/app/app.routes.ts

import { Routes } from '@angular/router';
import { loadRemoteModule } from '@angular-architects/native-federation';

export const routes: Routes = [
  { path: '', loadComponent: () => import('./home/home.component').then(m => m.HomeComponent) },
  {
    path: 'products',
    loadChildren: () =>
      loadRemoteModule({ type: 'manifest', remoteName: 'products', exposedModule: './ProductsModule' })
        .then(m => m.ProductsModule)
  },
  {
    path: 'orders',
    loadChildren: () =>
      loadRemoteModule({ type: 'manifest', remoteName: 'orders', exposedModule: './OrdersModule' })
        .then(m => m.OrdersModule)
  },
  {
    path: 'profile',
    loadChildren: () =>
      loadRemoteModule({ type: 'manifest', remoteName: 'profile', exposedModule: './ProfileModule' })
        .then(m => m.ProfileModule)
  },
  {
    path: 'reports',
    loadChildren: () =>
      loadRemoteModule({ type: 'manifest', remoteName: 'reports', exposedModule: './ReportsModule' })
        .then(m => m.ReportsModule)
  },
  {
    path: 'admin',
    loadChildren: () =>
      loadRemoteModule({ type: 'manifest', remoteName: 'admin', exposedModule: './AdminModule' })
        .then(m => m.AdminModule)
  }
];


shell/src/app/app.component.ts

import { Component, OnInit } from '@angular/core';
import { RouterLink, RouterOutlet } from '@angular/router';
import { UserStore } from './stores/user.store';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet, RouterLink],
  template: `
    <h1>üè† Shell App</h1>
    <nav>
      <a routerLink="/">Home</a> |
      <a routerLink="/products">Products</a> |
      <a routerLink="/orders">Orders</a> |
      <a routerLink="/profile">Profile</a> |
      <a routerLink="/reports">Reports</a> |
      <a routerLink="/admin">Admin</a>
    </nav>
    <div *ngIf="userStore.user() as user">Logged in: {{ user.name }}</div>
    <router-outlet></router-outlet>
  `
})
export class AppComponent implements OnInit {
  constructor(public userStore: UserStore) {}
  ngOnInit() { this.userStore.loadFromLocalStorage(); }
}


shell/src/app/stores/user.store.ts
import { Injectable, signal, computed } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class UserStore {
  private _user = signal<{ name: string } | null>(null);
  readonly user = computed(() => this._user());

  setUser(user: { name: string }) {
    this._user.set(user);
    localStorage.setItem('user', JSON.stringify(user));
  }

  loadFromLocalStorage() {
    const data = localStorage.getItem('user');
    if (data) this._user.set(JSON.parse(data));
  }

  clear() {
    this._user.set(null);
    localStorage.removeItem('user');
  }
}


shell/angular.json (snippet)

"federation": {
  "remotes": {
    "products": "https://products.mycompany.com/remoteEntry.json",
    "orders": "https://orders.mycompany.com/remoteEntry.json",
    "profile": "https://profile.mycompany.com/remoteEntry.json",
    "reports": "https://reports.mycompany.com/remoteEntry.json",
    "admin": "https://admin.mycompany.com/remoteEntry.json"
  }
}

üì¶ mfe-products/ (MFE1)
mfe-products/
 ‚îú‚îÄ src/app/products/
 ‚îÇ   ‚îú‚îÄ products.module.ts
 ‚îÇ   ‚îú‚îÄ products.component.ts
 ‚îÇ   ‚îî‚îÄ stores/products.store.ts
 ‚îî‚îÄ angular.json

mfe-products/src/app/products/products.module.ts
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { ProductsComponent } from './products.component';
import { CommonModule, NgFor, FormsModule } from '@angular/common';

@NgModule({
  declarations: [ProductsComponent],
  imports: [
    CommonModule,
    FormsModule,
    RouterModule.forChild([{ path: '', component: ProductsComponent }])
  ]
})
export class ProductsModule {}


mfe-products/src/app/products/products.component.ts
import { Component, OnInit } from '@angular/core';
import { ProductsStore } from './stores/products.store';

@Component({
  selector: 'app-products',
  standalone: true,
  template: `
    <h2>Products</h2>
    <input [(ngModel)]="newProduct" placeholder="New product">
    <button (click)="add()">Add</button>
    <ul>
      <li *ngFor="let p of store.products()">{{ p }}</li>
    </ul>
  `
})
export class ProductsComponent implements OnInit {
  newProduct = '';
  constructor(public store: ProductsStore) {}
  ngOnInit() { this.store.loadFromLocalStorage(); }
  add() {
    if (this.newProduct.trim()) {
      this.store.addProduct(this.newProduct.trim());
      this.newProduct = '';
    }
  }
}

mfe-products/src/app/products/stores/products.store.ts
import { Injectable, signal, computed } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class ProductsStore {
  private _products = signal<string[]>([]);
  readonly products = computed(() => this._products());

  addProduct(name: string) {
    const updated = [...this._products(), name];
    this._products.set(updated);
    localStorage.setItem('products', JSON.stringify(updated));
  }

  loadFromLocalStorage() {
    const data = localStorage.getItem('products');
    if (data) this._products.set(JSON.parse(data));
  }

  clear() {
    this._products.set([]);
    localStorage.removeItem('products');
  }
}


mfe-products/angular.json (snippet)
"federation": {
  "name": "products",
  "exposes": {
    "./ProductsModule": "./src/app/products/products.module.ts"
  }
}

Repeat same pattern for:
mfe-orders/ ‚Üí OrdersModule

mfe-profile/ ‚Üí ProfileModule

mfe-reports/ ‚Üí ReportsModule

mfe-admin/ ‚Üí AdminModule














*************************************************************************************************************
Original block you had (AppModule):

@NgModule({
  declarations: [
    AppComponent,
    PostListComponent,
    HomeComponent
  ],
  imports: [
    BrowserModule,
    RouterModule.forRoot([
      { path: '', component: HomeComponent },
      { path: 'posts', component: PostListComponent }
    ])
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
*************************************************************************************************************

 Refactored (Angular‚ÄØ20, standalone, app.config.ts + app.ts + main.ts)
 
 src/app/app.config.ts 
This is the new place to keep your routes, providers, etc.
import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';
import { routes } from './app.routes';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes)
  ]
};

src/app/app.routes.ts

import { Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { PostListComponent } from './post-list/post-list.component';

export const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'posts', component: PostListComponent }
];

src/app/app.component.ts  Make AppComponent standalone and import the components it needs.

import { Component } from '@angular/core';
import { RouterOutlet, RouterLink } from '@angular/router';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet, RouterLink],
  template: `
    <h1>My Angular 20 App</h1>
    <nav>
      <a routerLink="/">Home</a> |
      <a routerLink="/posts">Posts</a>
    </nav>
    <router-outlet></router-outlet>
  `
})
export class AppComponent {}

 
src/app/home/home.component.ts   ‚úÖ Make it standalone.
import { Component } from '@angular/core';

@Component({
  standalone: true,
  selector: 'app-home',
  template: `<h2>Home Component</h2>`
})
export class HomeComponent {}


üß© src/app/post-list/post-list.component.ts
import { Component } from '@angular/core';

@Component({
  standalone: true,
  selector: 'app-post-list',
  template: `<h2>Post List Component</h2>`
})
export class PostListComponent {}



üì¶ src/app/app.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { appConfig } from './app.config';

export function bootstrap() {
  return bootstrapApplication(AppComponent, appConfig);
}

 src/main.ts
 Ultra-light:
import { bootstrap } from './app/app';

bootstrap().catch(err => console.error(err));























